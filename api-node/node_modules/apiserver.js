/*global console:true, process: true, require:true, exports:true */
var
url = require('url'),
http = require('http'),
utils = require('utils'),

ENABLE_ACCESS_LOGGING = true,

VERSION = "1.0.0";

function ApiServer(config, database) {
    var onrequest = utils.applier(this, this._delegate);
    this._config = config;
    this._server = http.createServer(onrequest);
    this._database = database;
}

ApiServer.prototype = {
    _listen: function(port) {
        this._server.listen(port);
        console.log("API server listening to port %d...", port);
    },
    _method: function(request) {
        var name = url.parse(request.url).pathname.split('/').pop().toLowerCase();
        if (request.method === 'OPTIONS') {
           name = 'cors'; 
        } else {            
            if (name === '') {
                name = 'health';
            } else if (! (name in this)) {
                name = 'unknown';
            } else if (!this[name].call || this[name].call && name.substr(0, 1) === '_') {
                name = 'unauthorized';
            }            
        }
        return utils.applier(this, this[name]);
    },
    _delegate: function(request, response) {
        if (ENABLE_ACCESS_LOGGING) {
            console.log(request.method, request.url);
        }
        var method = this._method(request);
        try {
            utils.extractArgs(request,
            function(args) {
                method.call(null, request, response, args);
            });
        } catch(e) {
            console.error(e);
            this._respond(request, response, {
                error: 'Unexpected Server Error',
                status: 500
            });
        }
    },
    _respond: function(request, response, data, headers) {
        var body = '', status = 200, origin = request.headers.origin;
        headers = utils.extend({
            'Content-Type': 'application/json'
        }, headers || {});
        if (origin) { headers['Access-Control-Allow-Origin'] = origin; }
        if (data) {
            data.status = status;
            try { body = JSON.stringify(data); } 
            catch(e) {
                body = '{"error":"Unexpected Server Error"}';
                status = 500;
                console.error(e);
            }
        }        
        response.writeHead(status, headers);
        response.end(body);
        if (ENABLE_ACCESS_LOGGING) {
            console.log(status, body);
        }
    },
    user: function(request, response, args) {
        this._respond(request, response, {
            user_id: 1
        });
    },
    health: function(request, response, args) {
        this._respond(request, response, {
            service: 'Munitia API',
            version: VERSION
        });
    },
    unknown: function(request, response, args) {
        this._respond(request, response, {
            error: 'Unknown Action',
            status: 404
        });
    },
    unauthorized: function(request, response, args) {
        this._respond(request, response, {
            error: 'Unauthorized Action',
            status: 401
        });
    },
    cors: function(request, response, args) {
        var maxAge = 7200,
        requested = request.headers['Access-Control-Request-Headers'],
        methods = 'GET, POST, OPTIONS',
        headers = {            
            'Access-Control-Allow-Methods': methods,
            'Access-Control-Max-Age': maxAge 
        };
        if (requested) {
            headers['Access-Control-Allow-Headers'] = requested;
        }
        this._respond(request, response, null, headers);
    },
    add_to_round: function(args, response) {
	var server = this;
	lg = parseFloat(args.lg, 10);
	lt = parseFloat(args.lg, 10);
	console.error('calling add_to_round.');
	this._database.update({ collection: 'rounds',
		    criteria: { stretch_id: args.stretch_id, loc: { $near : [lg, lt]}, finished: false},
		    doc: { "$set": { stretch_id: args.stretch_id, loc: [lg, lt], finished: false },
			"$addToSet": { users: args.user_id} },
		    options: { upsert: true}}, function(error, docs) {
		console.error('Update returned!' + error + ' ' + docs);
		if (error != null) {
		    console.error('Error updating round: ' + error);
		    server._respond(response, { error: 'Updating round failed.', status: 500 });
		} else {
		    server._respond(response, docs);
		}
	    });   
    },
    find_round: function(args, response) {
	var server = this;
	lg = parseFloat(args.lg, 10);
	lt = parseFloat(args.lt, 10);
	console.error('calling find on rounds');
	this._database.find({ collection: 'rounds',
		    query: { loc: { $near : [lg, lt]}, stretch: args.stretch_id, finished: false}},
	    function(results) {
		console.error('returned from find.');
		if (results.length == 0) {
		    // Synchronize on round
		    round = {loc: [lg, lt], stretch: args.stretch_id, finished: false};
		    server._database.insert({ collection: 'rounds', docs: [round]}, function(results) {
			    if (results.length > 0) {
				round.roundId = results[0];
				server._respond(response, round);
			    } else {
				// Shouldn't happen!
				console.error('Inserting round failed: ' + sys.inspect(round));
				server._respond(response, { error: 'Inserting round failed.', status: 500 });
			    }
			});
		} else {
		    server._respond(response, results);
		}
	    });
    },
    find_round2: function(request, response, args) {
        var server = this,
        lg = parseFloat(args.lg, 10),
        lt = parseFloat(args.lt, 10);
        this._database.find({collection: 'rounds',
		    query: { loc: { $near: [lg, lt] }, stretch: args.stretch_id, finished: false}},
	    function(results) {
		if (results.length() === 0) {
		    // Synchronize on round
		    var round = {loc: [lg, lt], stretch: args.stretch_id, finished: false};
		    server._database.insert({ collection: 'rounds', docs: [round]}, function(results) {
			    if (results.length > 0) {
				round.roundId = results[0];
				server._respond(request, response, round);
			    } else {
				// Shouldn't happen!
				console.error('Inserting round failed:', round);
				server._respond(request, response, {error: 'Inserting round failed.', status: 500});
			    }
			});
		} else {
		    server._respond(request, response, results);
		}
	    });
    },
    find_stretch: function(request, response, args) {
        var server = this;
        this._database.find({ collection: 'stretches', 
		    query: { start_stop_id: args.start_stop_id, end_stop_id: args.end_stop_id, line_id: args.line_id}},
	    function(results) {
		server._respond(request, response, results);
	    });
    },
    create_stretch: function(request, response, args) {
	var server = this;
	var stretch = {start_stop_id: args.start_stop_id, end_stop_id: args.end_stop_id, line_id: args.line_id};
	server._database.insert({ collection: 'stretches', docs: [stretch]}, function(results) {
		if (results.length > 0) {
		    round.roundId = results[0];
		    server._respond(request, response, stretch);
		} else {
		    // Shouldn't happen!
		    console.error('Inserting stretch failed:', stretch);
		    server._respond(request, response, {error: 'Inserting stretch failed.', status: 500});
		}
	    });
    },
    add_round_score_to_stretch: function(request, response, args) {
	var server = this;
	var stretch_id = args.stretch_id;
	var new_round_score = { round_id: args.round_id, score: args.score };
	server._database.update({collection: 'stretches', 
				 criteria: { _id: args.stretch_id },
				 doc: { "$push": { "rounds" : new_round_score }},
				 options: { upsert: false}}, 
	    function(error, docs) {
		console.error('add_round returned ' + error + ' ' + docs);
		server._respond(request, response, results);
	    });
    },
    find_stops_near: function(request, response, args) {
        var server = this,
        longitude = parseFloat(args.lg, 10),
        latitude = parseFloat(args.lt, 10),
        limit = 5;
        if ("limit" in args) { limit = args.limit; }
        this._database.find({
            collection: 'stops',
            options: {
                limit: limit
            },
            query: {
                loc: {
                    $near: [longitude, latitude]
                }
            }
        },
        function(results) {
            server._respond(request, response, results);
        });
    },
    find_question: function(request, response, args) {
        var server = this,
        longitude = parseFloat(args.lg, 10),
        latitude = parseFloat(args.lt, 10),
        limit = 5;
        if ("limit" in args) { limit = args.limit; }
        this._database.find({
            collection: 'questions',
            query: {
                loc: {
                    $near: [longitude, latitude]
                }
            }
        },
        function(results) {
            server._respond(request, response, results);
        });
    },
    db_test: function(request, response, args) {
        var server = this;
        this._database.find({
            collection: 'test'
        },
        function(results) {
            server._respond(request, response, results);
        });
    }
};

exports.start = function(config, database) {
    var server = new ApiServer(config, database);
    server._listen(8080);
};